/*
 * Copyright (C) 2021 The Qing Project. All rights reserved.
 *
 * Use of this source code is governed by a license that can
 * be found in the LICENSE file.
 */

import * as mfs from 'm-fs';
import nodePath from 'path';
import yaml from 'js-yaml';
import { genGoType, TypeMember } from 'gen-go-type';
import {
  copyrightString,
  sodPath,
  webSodPath,
  serverSodPath,
  serverPath,
} from '../common/common.js';

const yamlExt = '.yaml';
const goOutDirAttr = '__go_out_dir';

const input = process.argv.slice(2)[0];
if (!input) {
  console.log('No input.');
  process.exit(1);
}

type SourceDict = Record<string, Record<string, string>>;

function noticeComment(input: string): string {
  return ` /******************************************************************************************
  * Do not edit this file manually.
  * Automatically generated via \`qing sod ${input}\`
  * See \`lib/dev/sod/objects/${input}.yaml\` for details.
  ******************************************************************************************/\n\n`;
}

function capitalize(s: string) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

function goCode(input: string, pkgName: string, dict: SourceDict): string {
  let s = '';
  let isFirst = true;
  for (const [clsName, fields] of Object.entries(dict)) {
    if (isFirst) {
      isFirst = false;
    } else {
      s += '\n';
    }
    let members: TypeMember[] = [];
    for (const [k, v] of Object.entries(fields)) {
      members.push({
        name: capitalize(k),
        type: v,
        tag: `\`json:"${k}"\``,
      });
    }
    s += genGoType('struct', clsName, members);
  }
  return copyrightString + noticeComment(input) + `package ${pkgName}\n\n` + s;
}

function sourceTypeFieldToTSType(type: string): string {
  switch (type) {
    case 'bool':
      return 'boolean';
    case 'int':
    case 'uint64':
    case 'double':
      return 'number';
    case 'string':
      return 'string';
    default:
      return type;
  }
}

function tsCode(input: string, dict: SourceDict): string {
  let s = '';
  let isFirst = true;
  for (const [clsName, fields] of Object.entries(dict)) {
    if (isFirst) {
      isFirst = false;
    } else {
      s += '\n';
    }
    s += `export interface ${clsName} {\n`;
    for (const [k, v] of Object.entries(fields)) {
      s += `  ${k}?: ${sourceTypeFieldToTSType(v)};\n`;
    }
    s += `}\n`;
  }
  return '/* eslint-disable */\n\n' + copyrightString + noticeComment(input) + s;
}

function trimYAMLExtension(s: string): string {
  return s.substr(0, s.length - yamlExt.length);
}

function print(s: string) {
  console.log(s);
}

function getDictAttribute(dict: Record<string, string>, key: string): string | null {
  const val = dict[key];
  if (val) {
    delete dict[key];
    return val;
  }
  return null;
}

(async () => {
  try {
    const fullInput = sodPath(input + yamlExt);
    const rawSource = yaml.load(await mfs.readTextFileAsync(fullInput));
    if (typeof rawSource !== 'object' || Array.isArray(rawSource)) {
      throw new Error(`Source YAML must be an object. Got ${JSON.stringify(rawSource)}`);
    }

    function getAttr(key: string): string | null {
      return getDictAttribute(rawSource as Record<string, string>, key);
    }

    const srcDict = rawSource as SourceDict;
    const relPath = nodePath.relative(sodPath(), fullInput);
    const relPathWithoutYAMLExt = trimYAMLExtension(relPath);
    const inputFileName = nodePath.basename(input);
    const pkgName = inputFileName;
    const webFile = nodePath.join(webSodPath(), relPathWithoutYAMLExt) + '.ts';

    const goFileName = inputFileName + '.go';
    const goOutDir = getAttr(goOutDirAttr);
    let serverFile: string;
    if (goOutDir) {
      serverFile = nodePath.join(serverPath(), goOutDir, goFileName);
    } else {
      // NOTE: Unlike .ts file, .go files are put in an extra folder named the same as the extracted package name.
      serverFile = nodePath.join(serverSodPath(), relPathWithoutYAMLExt, goFileName);
    }

    await Promise.all([
      mfs.writeFileAsync(serverFile, goCode(input, pkgName, srcDict)),
      mfs.writeFileAsync(webFile, tsCode(input, srcDict)),
    ]);
    print(`Files written:`);
    print(serverFile);
    print(webFile);
  } catch (err) {
    console.error(err);
    process.exit(1);
  }
})();
