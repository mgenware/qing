/*
 * Copyright (C) 2021 The Qing Project. All rights reserved.
 *
 * Use of this source code is governed by a license that can
 * be found in the LICENSE file.
 */

import isPlainObj from 'is-plain-obj';

export const attrPrefix = '__';
export const daPathPrefix = ':da';
export const sodPathPrefix = ':sod:';

const allowedAttrs = new Set<string>();
const scopedProp = /_([a-z]+)__/;

function checkAttr(attr: string) {
  if (!allowedAttrs.has(attr)) {
    throw new Error(`Unknown attr ${attr}`);
  }
}

export function addAllowedAttrs(attrs: string[]) {
  for (const attr of attrs) {
    allowedAttrs.add(attr);
  }
}

export type SourceDict = Record<string, Record<string, unknown>>;

export function noticeComment(input: string): string {
  return `/******************************************************************************************
 * Do not edit this file manually.
 * Automatically generated via \`qing sod ${input}\`.
 * See \`lib/dev/sod/objects/${input}.yaml\` for details.
 ******************************************************************************************/\n\n`;
}

export function capitalizeFirstLetter(s: string) {
  if (s === 'id') {
    return 'ID';
  }
  return s.charAt(0).toUpperCase() + s.slice(1);
}

export function lowerFirstLetter(s: string) {
  if (s === 'ID') {
    return 'id';
  }
  return s.charAt(0).toLocaleLowerCase() + s.slice(1);
}

export function popDictAttribute(dict: Record<string, string>, key: string): string | null {
  const val = dict[key];
  if (val) {
    // eslint-disable-next-line no-param-reassign
    delete dict[key];
    return val;
  }
  return null;
}

export interface ExtendsField {
  name: string;
  path?: string;
  packageName?: string;
}

function parseExtendsFieldObj(obj: unknown): ExtendsField {
  if (!isPlainObj(obj)) {
    throw new Error(`Expected an object, got ${JSON.stringify(obj)}`);
  }
  const objDict = obj as Record<string, string>;
  const { name, path, packageName } = objDict;
  if (!name) {
    throw new Error(`Missing name param. Got ${JSON.stringify(obj)}`);
  }
  return { name, path, packageName };
}

export function parseExtendsValue(obj: unknown): ExtendsField[] {
  if (!Array.isArray(obj)) {
    throw new Error(`Expected an array, got ${JSON.stringify(obj)}`);
  }
  return obj.map((o) => parseExtendsFieldObj(o));
}

export function parseRenameMap(obj: unknown): Record<string, string> {
  if (typeof obj !== 'object') {
    throw new Error(`Expected an object, got ${JSON.stringify(obj)}`);
  }
  return obj as Record<string, string>;
}

export interface PropertyTraits {
  // `prop?`
  // Go: use pointer type
  // TS: no effect, always optional (due to omitempty)
  optional: boolean;
  // `prop[]`
  isArray: boolean;
  // `prop!`
  // Go: no effect
  // TS: not optional
  notEmpty: boolean;
}

export function scanTypeDef(
  go: boolean, // true for Go, false for TypeScript.
  src: Record<string, unknown>,
  attrCb: (k: string, v: unknown) => void,
  propCb: (k: string, v: string, traits: PropertyTraits) => void,
) {
  // Handle attrs first.
  for (const [k, v] of Object.entries(src)) {
    if (k.startsWith(attrPrefix)) {
      checkAttr(k);
      attrCb(k, v);
    } else {
      continue;
    }
  }

  // eslint-disable-next-line @typescript-eslint/naming-convention
  for (const [_name, _type] of Object.entries(src)) {
    if (_name.startsWith(attrPrefix)) {
      continue;
    } else {
      if (typeof _type !== 'string') {
        throw new Error(`Property value must be a string. Got ${JSON.stringify(_type)}`);
      }
      let skipThisProp = false;
      const optional = _type.endsWith('?');
      let type = optional ? _type.substring(0, _type.length - 1) : _type;

      const notEmpty = type.endsWith('!');
      type = notEmpty ? type.substring(0, type.length - 1) : type;

      const isArray = type.endsWith('[]');
      type = isArray ? type.substring(0, type.length - 2) : type;

      let name = _name;
      if (name.endsWith('__')) {
        const match = scopedProp.exec(name);
        if (!match?.length) {
          throw new Error(`Invalid scope property format: "${name}"`);
        }

        const scopeName = match[1];
        if (!scopeName) {
          throw new Error(`Unexpected scope name in property: "${name}"`);
        }

        if (scopeName === (go ? 'go' : 'ts')) {
          // Remove the trailing scope value.
          // E.g. `goOnlyProp_go__` -> `goOnlyProp`.
          name = name.substring(0, name.length - match[0]!.length ?? 0);
        } else {
          skipThisProp = true;
        }
      }
      if (!skipThisProp) {
        propCb(name, type, { optional, isArray, notEmpty });
      }
    }
  }
}
