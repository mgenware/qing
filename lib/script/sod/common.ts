/*
 * Copyright (C) 2021 The Qing Project. All rights reserved.
 *
 * Use of this source code is governed by a license that can
 * be found in the LICENSE file.
 */

import isPlainObj from 'is-plain-obj';

export const attrPrefix = '__';
const extendsAttr = '__extends';

const allowedAttrs = new Set<string>([extendsAttr]);
const scopedProp = /_([a-z]+)__/;

function checkAttr(attr: string) {
  if (!allowedAttrs.has(attr)) {
    throw new Error(`Unknown attr ${attr}`);
  }
}

export function addAllowedAttrs(attrs: string[]) {
  for (const attr of attrs) {
    allowedAttrs.add(attr);
  }
}

export type SourceDict = Record<string, Record<string, unknown>>;

export function noticeComment(input: string): string {
  return `/******************************************************************************************
 * Do not edit this file manually.
 * Automatically generated via \`qing sod ${input}\`.
 * See \`lib/dev/sod/objects/${input}.yaml\` for details.
 ******************************************************************************************/\n\n`;
}

export function capitalizeFirstLetter(s: string) {
  if (s === 'id') {
    return 'ID';
  }
  return s.charAt(0).toUpperCase() + s.slice(1);
}

export function lowerFirstLetter(s: string) {
  if (s === 'ID') {
    return 'id';
  }
  return s.charAt(0).toLocaleLowerCase() + s.slice(1);
}

export function popDictAttribute(dict: Record<string, string>, key: string): string | null {
  const val = dict[key];
  if (val) {
    // eslint-disable-next-line no-param-reassign
    delete dict[key];
    return val;
  }
  return null;
}

export interface ExtendsObjValue {
  name: string;
  path?: string;
  packageName?: string;
}

export type ExtendsField = string | ExtendsObjValue;

function parseExtendsFieldObj(obj: unknown): ExtendsField {
  if (typeof obj === 'string') {
    return obj;
  }
  if (!isPlainObj(obj)) {
    throw new Error(`Expected an object, got ${JSON.stringify(obj)}`);
  }
  const objDict = obj as Record<string, string>;
  const { name, path, packageName } = objDict;
  if (!name) {
    throw new Error(`Missing name param. Got ${JSON.stringify(obj)}`);
  }
  return { name, path, packageName };
}

function parseExtends(obj: unknown): ExtendsField[] {
  if (typeof obj === 'string') {
    return [parseExtendsFieldObj(obj)];
  }
  if (!Array.isArray(obj)) {
    throw new Error(`Expected an array, got ${JSON.stringify(obj)}`);
  }
  return obj.map((o) => parseExtendsFieldObj(o));
}

export function parseRenameMap(obj: unknown): Record<string, string> {
  if (typeof obj !== 'object') {
    throw new Error(`Expected an object, got ${JSON.stringify(obj)}`);
  }
  return obj as Record<string, string>;
}

export function parseImports(obj: unknown): string[] {
  if (!Array.isArray(obj)) {
    throw new Error(`Expected an array, got ${JSON.stringify(obj)}`);
  }
  for (const el of obj) {
    if (typeof el !== 'string') {
      throw new Error(`\`imports\` member must be a string, got "${el}"`);
    }
  }
  return obj as string[];
}

export interface PropertyTraits {
  // `prop?`
  // Go: use pointer type
  // TS: no effect, always optional (due to omitempty)
  optional: boolean;
  // `prop[]`
  isArray: boolean;
  // `prop!`
  // Go: no effect
  // TS: not optional
  notEmpty: boolean;
}

export interface CommonAttrData {
  extends?: ExtendsField[];
}

export function scanTypeDef(
  go: boolean, // true for Go, false for TypeScript.
  src: Record<string, unknown>,
  customAttrCb: (k: string, v: unknown) => void,
  propCb: (k: string, v: string, traits: PropertyTraits) => void,
) {
  const attrData: CommonAttrData = {};
  // Handle attrs first.
  for (const [k, v] of Object.entries(src)) {
    if (k.startsWith(attrPrefix)) {
      checkAttr(k);

      switch (k) {
        case extendsAttr: {
          attrData.extends = parseExtends(v);
          break;
        }

        default: {
          // Pass unknown attrs to custom callback.
          customAttrCb(k, v);
          break;
        }
      }
    } else {
      continue;
    }
  }

  // eslint-disable-next-line @typescript-eslint/naming-convention
  for (const [_name, _type] of Object.entries(src)) {
    if (_name.startsWith(attrPrefix)) {
      continue;
    } else {
      let rawType: string;
      if (typeof _type === 'string') {
        rawType = _type;
      } else if (_type && typeof _type === 'object') {
        rawType = (_type as any)[go ? 'go' : 'ts'];
      } else {
        throw new Error(`Invalid type. "${_name}: ${_type}"`);
      }
      if (!rawType) {
        throw new Error(`Empty type. "${_name}: ${_type}"`);
      }

      let skipThisProp = false;
      const optional = rawType.endsWith('?');
      let type = optional ? rawType.substring(0, rawType.length - 1) : rawType;

      const notEmpty = type.endsWith('!');
      type = notEmpty ? type.substring(0, type.length - 1) : type;

      const isArray = type.endsWith('[]');
      type = isArray ? type.substring(0, type.length - 2) : type;

      let name = _name;
      if (name.endsWith('__')) {
        const match = scopedProp.exec(name);
        if (!match?.length) {
          throw new Error(`Invalid scope property format: "${name}"`);
        }

        const scopeName = match[1];
        if (!scopeName) {
          throw new Error(`Unexpected scope name in property: "${name}"`);
        }

        if (scopeName === (go ? 'go' : 'ts')) {
          // Remove the trailing scope value.
          // E.g. `goOnlyProp_go__` -> `goOnlyProp`.
          name = name.substring(0, name.length - match[0]!.length ?? 0);
        } else {
          skipThisProp = true;
        }
      }
      if (!skipThisProp) {
        propCb(name, type, { optional, isArray, notEmpty });
      }
    }
  }
  return attrData;
}

export enum SpecialType {
  da = 'da',
  sod = 'sod',
}

// `type` example: `:sod.a.b.c`.
export function parseSpecialType(type: string): [SpecialType, string] {
  // Get type prefix.
  const idx = type.indexOf('.');
  if (idx < 0) {
    throw new Error(`Invalid type "${type}"`);
  }
  const prefix = type.substring(1, idx);
  const rest = type.substring(idx + 1);
  let resolved: SpecialType;
  switch (prefix) {
    case SpecialType.da:
      resolved = SpecialType.da;
      break;

    case SpecialType.sod:
      resolved = SpecialType.sod;
      break;

    default:
      throw new Error(`Unsupported prefix "${prefix}"`);
  }
  return [resolved, rest];
}

// `s`: type string extracted from `parseSpecialType`. e.g. `cmt.cmt.Cmt`.
export function parseSodSpecialTypeString(s: string): { file: string; type: string } {
  // Get type prefix.
  const idx = s.lastIndexOf('.');
  if (idx < 0) {
    throw new Error(`Invalid SOD type "${s}"`);
  }
  return {
    // The file path is separated by '.', replace them with '/'.
    file: s.substring(0, idx).replaceAll('.', '/'),
    type: s.substring(idx + 1),
  };
}
